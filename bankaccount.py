# -*- coding: utf-8 -*-
"""bankAccount.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CWbtaylCsFZ_Uzl4DodeBe4-hFBoGHHg
"""

#Louise Capener

import random
import datetime
#Imported the random module to create theCardNum() and datetime to create theCardExp()



#*************************************************************************************************************************************

class BasicAccount:
    """
    Basic Account is an account holder with a Basic Account subscription. Has a name and an opening balance.
    """

    #Class side variable which will be incremented by 1 everytime self.acNum instance is initialized
    accountNum = 0

#BASIC ACCOUNT (superclass) CLASS METHODS:


#Tells us what data will be within each Bank Account instance that is created:
    def __init__(self, theName, openingBalance):
        """
        This dunder method will indicate what data must be supplied, and how it will be stored.

        Parameters:
        theName: string - the name will be stored in the instance
        openingBalance: float - the opening balance will be stored in the instance

        Returns:
        Nothing
        """
        self.name = theName
        BasicAccount.accountNum += 1
        self.acNum = BasicAccount.accountNum
        self.balance = float(openingBalance)
        self.cardNum = BasicAccount.theCardNum()
        self.cardExp = BasicAccount.theCardExp()

#Produces informative output about the particular instance being printed
    def __str__(self):
        return "This account belongs to {name}. Their account has an available balance of £{balance}.".format(name =self.name, balance = self.getAvailableBalance())

    def getName(self):
        """
        getName will return the account holder's name.

        Parameters:
        None

        Returns:
        string - the name of the Basic Account instance
        """
        return self.name

    def getAcNum(self):
        """
        getAcNum will return the customer's account number

        Parameters:
        None

        Returns:
        string - an account number for the Basic Account instance
        """
        return self.acNum
        #Each instance will have a unique account number

    def getBalance(self):
        """
        getBalance will return the balance of the Basic Account instance

        Parameters:
        None

        Returns:
        float - the balance of the Basic Account instance
        """
        return self.balance

    def getAvailableBalance(self):
        """
        getAvailableBalance will return the available balance of the Basic Account instance

        Parameters:
        None

        Returns:
        float - the available balance of the Basic Account instance
        """
        return self.balance

    def printBalance(self):
        """
        printBalance will print the balance of the Basic Account instance

        Parameters:
        None

        Returns:
        Nothing
        """
        print ("Account balance: {}{}".format("£", self.balance))
        #The format method has been used here for presentation reasons, so that the "£" appears in front of the float

    def deposit(self, theAmount):
        """
        deposits the stated amount into the Basic Account instance, and adjusts the balance

        Parameters:
        theAmount: float - the amount to be deposited into the account

        Returns:
        Nothing
        """
        self.theAmount = float(theAmount)
        #Float stipulates the data type for the argument "theAmount" which is being passed in
        if theAmount > 0:
            #This action can only be completed if the amount is positive
            print(self.name,"has deposited", "{}{}".format("£", theAmount))
            #The balance for the instance is then adjusted accordingly
            self.balance = self.theAmount + self.balance
        else:
            print("Error. Account cannot accept a negative amount.")

    def withdraw(self, withAmount):
        """
        withdraws the stated amount from the Basic Account instance, if the requested amount is less than or equal to the available balance

        Parameters:
        withAmount: float - the amount to be withdrawn from the account

        Returns:
        Nothing
        """
        self.withAmount = withAmount
        if withAmount <= self.getAvailableBalance():
            #This allows the account holder to withdraw an amount, only if it is smaller than (or equal to) their available balance
            print(self.name, "has withdrew","{}{}".format("£", withAmount))
            #The balance for the instance is then adjusted accordingly, as it was with the deposit method
            self.balance = self.balance - withAmount
            print("New balance is","{}{}".format("£",self.balance))
        else:
            #If the amount requested is greater than the available balance, the following message is printed to the screen
            print("Can not withdraw", "{}{}".format("£",withAmount))

    @staticmethod
    #This method is static, as it does not depend on anything from the class or instance
    def theCardNum():
        """
        theCardNum will generate a 16 digit number for the Basic Account instance

        Parameters:
        None

        Returns:
        string - a string of 16 digit numbers
        """
        return ''.join(str(random.randint(0, 9)) for _ in range(16))
        #The random module (imported at the top of the page) was used to generate a random 16 digit number for each instance

    @staticmethod
    #This method is static, as it does not depend on anything from the class or instance
    def theCardExp():
        """
        theCardExp will generate a card expiry date

        Parameters:
        None

        Returns:
        tuple - the card expiry date, set 3 years from now
        """
        date = datetime.datetime.now()
        date = date.replace(year = date.year + 3)
        #In order to generate the expiry date, the datetime module (imported at the top of the page) was utilized
        #The current date was imported, and then set 3 years from now, whilst the month remained the same
        return tuple([date.strftime("%m/%y")])
        #The strftime method allowed for the date to be presented in an appropriate format for a bank account, i.e: m/y


    def issueNewCard(self):
        """
        issueNewCard will return a card number and card expiry date for the Basic Account instance

        Parameters:
        None.

        Returns:
        string - the card number that is randomly generated
        tuple - the card expiry date, set 3 years from now
        """
        #Within this method, the static methods are called to generate the information necessary for a new card
        self.cardNum = BasicAccount.theCardNum()
        self.cardExp = BasicAccount.theCardExp()
        return '{}{}'.format(self.cardNum, self.cardExp)

    def closeAccount(self):
        """
        closeAccount will return any available balance to the customer if the balance is greater than 0
        closeAccount returns False if this is not the case

        Parameters:
        None

        Returns:
        boolean value - True or False
        """
        if self.balance > 0:
            #Returns any remaining balance to the account holder
            self.withdraw(self.balance)
            return True
        else:
            #In the case of the Bank Account class, the balance cannot be negative as there is no available overdraft
            return False






#*************************************************************************************************************************************






class PremiumAccount(BasicAccount):
    """
    Premium Account is an account holder with a Premium Account subscription. Has a name, an opening balance and an initial overdraft.
    """

#PREMIUM ACCOUNT (subclass) CLASS METHODS:


#(Dunder method): Tells us what data will be within each Bank Account instance that is created:
    def __init__ (self, theName, openingBalance, initialOverdraft):
        """
        This dunder method will indicate what data must be supplied, and how it will be stored.

        Parameters:
        theName: string - the name will be stored in the instance
        openingBalance: float - the opening balance will be stored in the instance
        initialOverdraft: float - the initial overdraft will be stored in the instance
        """
        super().__init__(theName, openingBalance)
        #This calls the super constructor, the initializer of the superclass (Bank Account)
        self.limit = float(initialOverdraft)
        #Float stipulates the data type for the initial overdraft
        self.overdraft = self.overdraftCheck()

#(Dunder method):Produces informative output about the particular instance being printed
    def __str__(self):
        return "This account belongs to {name}. The account has an available balance of £{balance}. The account has an overdraft: {boolean}. The overdraft limit is £{overdraft}.".format(name =self.name, balance = self.getAvailableBalance(), boolean = self.overdraftCheck(), overdraft = self.limit)
        #This subclass also outputs information about whether the account has an overdraft, and what its limit is.

    def overdraftCheck(self):
        """
        overdraft will return False if the overdraft limit is 0, and True if it is greater than 0

        Parameters:
        None

        Returns:
        boolean value - True or False
        """
        if self.limit == 0:
            #This means if (when the instance is created) initialOverdraft is passed in as 0, False will be returned
            return False
        elif self.limit > 0:
            return True
        else:
            print("Error. Negative values not accepted.")
            #This ensures that no negative values are entered when creating the instance

    def setOverdraftLimit(self, newLimit):
        """
        setOverdraftLimit will set the overdraft limit for the Premium Account instance.

        Parameters:
        newLimit: float - the new overdraft limit of the premium account instance

        Returns:
        Nothing
        """

        if self.overdraft == True and self.balance < 0:
            #This means if the account has an overdraft available, and its balance is less than 0, a debT value is created
            #debT shows how much the account is overdrawn by
            debT = self.balance - self.getAvailableBalance()
            self.limit = float(newLimit)
            #Then if the new limit is smaller than the absolute value of the debt, the account holder cannot set a new lower limit
            if newLimit < abs(debT):
                print("Can't set new limit lower than the amount the account is overdrawn by")
            else:
                #If however, the account has an overdraft available, and its balance is less than 0 BUT the new limit is greater than the absolute value of the debt...
                #The account user is then allowed to update their overdraft limit
                print("Your overdraft limit is now set to", newLimit)
        else:
            #Alternatively, if the Premium Account has been created with an initial overdraft of 0, then the account holder cannot set a new limit
            print("Can't set overdraft limit for this account")

    def getAvailableBalance(self):
        """
        getAvailableBalance will return the available balance for the Premium Account instance
        It includes any overdraft, and adds it to the balance

        Parameters:
        None

        Returns:
        float - the available balance for the Premium Account instance
        """
        return self.balance + self.limit
        #This ensures that the available balance considers the account holders overdraft too

    def getBalance(self):
        """
        getBalance will return the balance for the Premium Account instance
        Returns a negative value if the account is overdrawn

        Parameters:
        None

        Returns:
        float - balance for the Premium Account instance
        """
        return self.balance
        #Unlike the available balance method, getBalance does not consider the account holders overdraft

    def printBalance(self):
        """
        printBalance will print the balance of the Premium Account instance

        Parameters:
        None

        Returns:
        Nothing
        """
        print ("{}{}".format("Account balance: £", self.balance))
        if self.overdraft == True:
            #This prints the overdraft limit if the Premium Account holder has one
            print ("Overdraft limit: {}{}".format("£",self.limit))
            if self.getBalance() < 0:
                #If getBalance is less than 0, the remaining overdraft is calculated
                remaining = self.limit + self.getBalance()
                print("Overdraft remaining:",remaining)
            else:
                #If getBalance is greater than 0, it means the overdraft has not been used so the overdraft limit is printed
                print("Overdraft remaining:", self.limit)

    def withdraw(self, withAmount):
        """
        withdraws the stated amount from the Premium Account instance, if the requested amount is less than or equal to the available balance

        Parameters:
        withAmount: float - the amount to be withdrawn from the account

        Returns:
        Nothing
        """
        if withAmount <= self.getAvailableBalance():
            #This takes into consideration the account holders overdraft, allowing them to withdraw an amount that does not exceed self.balance + self.limit
            self.balance = self.balance - withAmount
            #The account holder's balance is then adjusted accordingly
            print(self.name, "has withdrew","{}{}".format("£", withAmount))
        else:
            #If the requested amount is larger than the available balance, the difference is calculated
            #The account holder is then informed that in order to withdraw the desired amount they need the specified amount
            diff = withAmount - self.getAvailableBalance()
            print("Can not withdraw", "{}{}".format("£",withAmount), "n/To complete this transaction you need:", "{}{}".format("£", diff))

    def closeAccount(self):
        """
        closeAccount will return True if the account holder has any remaining balance
        Any remaining balance will be returned to the customer
        closeAccount will return False if the account is overdrawn

        Parameters:
        None

        Returns:
        boolean value - True or False
        """
        if self.balance > 0:
            self.withdraw(self.balance)
            #Returns any remaining balance to the account holder
            return True
        else:
            #If the account holders balance is negative, the debt that they owe is calculated
            debT = self.balance - self.getAvailableBalance()
            print("Can not close account due to customer being overdrawn by", debT)
            return False



#*************************************************************************************************************************************



#Test code that has been prevented from automatically running once file is imported
if __name__ == "__main__":
    ba1 = BasicAccount("John", 100.0)
    ba2 = BasicAccount("Charlotte", 50.60)
    pa1 = PremiumAccount("Bob", 250.60, 40.0)
    pa2 = PremiumAccount("Rachel", 30.0, 0)