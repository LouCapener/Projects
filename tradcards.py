# -*- coding: utf-8 -*-
"""tradCards.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1i0utReOlisqVPAMRFUJqRn7d5-Uy5K2J
"""

#Louise Capener



import openpyxl
#Imported the openpyxl module to manage data contained in an excel file


#*************************************************************************************************************************************


class Card:
    """
    Card class is comprised of trading cards.
    Each card instance has a name, type, maximum health points, 1-5 moves, and a shiny status.
    """

#CARD CLASS - METHODS:


    #Tells us what data will be within each Card instance that is created:
    def __init__(self, theName, theType, theHP, theMoves, isShiny):
        """
        This dunder method will indicate what data must be supplied and how it will be stored.

        Parameters:
        theName: string - the name will be stored in the instance
        theType: string - the type will be stored in the instance
        theHP: integer - the HP will be stored in the instance
        theMoves: dictionary - the moves will be stored in the instance
        isShiny: integer - the shiny status will be stored in the instance

        Returns:
        Nothing

        """

        if isinstance(theName, str):
            self.name = theName

        #Error handling for self.name if type is incorrect and length >0
        try:
            if isinstance(theName, str) and len(theName) >0:
                print("Success: theName type is correct")
            else:
                raise AttributeError
        except AttributeError:
                print("Attribute Error: In order to assign theName attribute, it must be a string with a length > 0")

        if theType == "Magi":
            self.type = theType
        elif theType == "Water":
            self.type = theType
        elif theType == "Fire":
            self.type = theType
        elif theType == "Earth":
            self.type = theType
        elif theType == "Air":
            self.type = theType
        elif theType == "Astral":
            self.type = theType
        else:
            print("Error. theType must be either: Magi, Water, Fire, Earth, Air, or Astral.")


        #Error handling for self.type if type is incorrect
        try:
            if isinstance(theType, str):
                print("Success: theType is correct")
            else:
                raise TypeError
        except TypeError:
            print("TypeError: theType must be a string")

        if type(theHP) is int:
            self.HP = theHP

        #Error handling for self.HP if type is incorrect
        try:
            if isinstance(theHP, int):
                print("Success: theHP type is correct")
            else:
                raise ValueError
        except ValueError:
            print("ValueError: theHP must be an integer")


        if len(theMoves) <= 5 and len(theMoves) != 0 and isinstance(theMoves,dict):
            self.moves = theMoves

        #Error handling for self.moves if length is incorrect
        try:
            if len(theMoves) <= 5 and len(theMoves) != 0:
                print("Success: theMoves length is correct")
            else:
                raise AttributeError
        except AttributeError:
            print("AttributeError: In order to assign theMoves attribute, the length of theMoves must be correct.")


        #Error handling if self.moves type is incorrect
        try:
            if isinstance(theMoves, dict):
                print("Success: theMoves type is correct")
            else:
                raise TypeError
        except TypeError:
            print("TypeError: theMoves should be contained in a dictionary")


        if isShiny == 1:
            self.shiny = isShiny
            isShiny = True
        elif isShiny == 0:
            self.shiny = isShiny
            isShiny = False
        else:
            #If a binary value is not present then isShiny is not assigned
            print("Error. isShiny must be a binary value: 0 or 1.")

        #Error handling if self.shiny type is incorrect
        try:
            if isinstance (isShiny, int):
                print("Success: isShiny type is correct")
            else:
                raise TypeError
        except TypeError:
            print("TypeError: isShiny should be an integer")

        self.averageDamage = self.getAverageDamage()


    #Produces informative output about the particular instance being printed
    def __str__(self):
        """
        This dunder method will provide a string representation of a card's information.

        Parameters:
        None.

        Returns:
        string - the information associated with a given card
        """

        try:
            return "This is a {name} card. It is {type} type, and has a Maximum HP of {HP}. It has the following moves: {moves}. It is a shiny card: {shiny}.".format(name = self.name, type = self.type, HP = self.HP, moves = self.moves, shiny = bool(self.shiny))
        except AttributeError:
            print("AttributeError: Cards object is missing an attribute")

    def getAverageDamage(self):
        """
        Calculates the average damage of a Card instance

        Parameters:
        None.

        Returns:
        integer - the average damage value of an individual card

        """

        #An average is calculated by collecting the value of each card move then adding them together and dividing by the number of moves
        damageValues = self.moves.values()
        return sum(damageValues) / len(damageValues)



#*************************************************************************************************************************************



class Deck:
    """
    Deck is designed to hold instances of the card class
    """

#DECK CLASS - METHODS:

    #Tells us what data will be within each Deck instance that is created:
    def __init__(self):
        """
        This dunder method will indicate what data must be supplied and how it will be stored.

        Parameters:
        None.

        Returns:
        Nothing.
        """
        #Initialise an empty deck every time a new instance of this class is created
        self.cards = []
        print("New deck made")

    #Produces informative output about the particular instance being printed
    def __str__(self):
        """

        This dunder method will provide a string representation of the deck

        Parameters:
        None.

        Returns:
        Nothing.

        """
        for card in self.cards:
            print(card)

    def getNoOfCards(self):
        """

        Displays the number of cards held within the deck

        Parameters:
        None.

        Returns:
        integer - the amount of cards in the deck

        """

        #Counts how many cards are contained in the self.cards list
        return len(self.cards)

    def inputFromFile(self, fileName):
        """

        Utilises openpyxl module to access contents of excel file
        The contents of the file are added to an empty deck

        Parameters:
        fileName - the fileName will specify which excel file is being accessed

        Returns:
        Nothing

        """

        self.book = openpyxl.load_workbook(fileName)
        sheet = self.book.active

        for row in sheet.iter_rows(min_row = 2):
            #If this row is not empty access the row values
            if row[0].value != None:
                theName = row[0].value
                theType = row[1].value
                theHP = row[2].value

            theMoves = {row[4].value: row[5].value}
            #Check moves exist before adding them
            if row[6].value != None:
                theMoves[row[6].value] = row[7].value
            if row[8].value != None:
                theMoves[row[8].value] = row[9].value
            if row[10].value != None:
                theMoves[row[10].value] = row[11].value
            if row[12].value != None:
                theMoves[row[12].value] = row[13].value

            if row[3].value != None:
                isShiny = row[3].value

                #Print relevant information for the card instance that is being created
                newCard = Card(theName, theType, theHP, theMoves, isShiny)

                #Add the new card to the deck
                self.addCard(newCard)

    def addCard(self, theCard):
        """
        Adds a card to a Deck instance

        Parameters:
        theCard - the specific card that has been selected

        Returns:
        Nothing.

        """

        #Adds the card to the self.cards list
        self.cards.append(theCard)

    def rmCard(self, theCard):
        """

        Removes a card instance from the deck

        Parameters:
        theCard - the specific card that has been selected

        Returns:
        Nothing.

        """

        #Removes the card from the self.cards list
        self.cards.remove(theCard)

    def getMostPowerful(self):
        """
        Returns the card that is most powerful

        Parameters:
        None.

        Returns:
        card that has the highest damage value
        """

        maxDamage = 0
        #First, find maxDamage
        for card in self.cards:
            if card.averageDamage > maxDamage:
                maxDamage = card.averageDamage

        #Then, find card with maxDamage
        for card in self.cards:
            if card.averageDamage == maxDamage:
                return card

    def getAverageDamage(self):
        """
        Calculates and returns the average damage of all cards in the deck

        Parameters:
        None.

        Returns:
        Average damage value of the deck, rounded to 1 decimal point
        """

        total = 0

        for card in self.cards:
            #Collects the averageDamage for each card within the Deck
            total = total + card.averageDamage

        #The total averageDamage is then divided by the number of cards in the deck
        return round(total / self.getNoOfCards(), 1)

    def viewAllCards(self):
        """
        Prints the information of all cards in the deck

        Parameters:
        None.

        Returns:
        Nothing.
        """

        for card in self.cards:
            print(card)

    def viewAllShinyCards(self):
        """
        Prints the information of all the shiny cards in the deck

        Parameters:
        None.

        Returns:
        Nothing.

        """

        for card in self.cards:
            if card.shiny:
                print(card)

    def viewAllByType(self, theType):
        """
        Prints the information of all cards of a specific type in the deck

        Parameters:
        theType - the specific type that has been selected

        Returns:
        Nothing.

        """

        for card in self.cards:
            if card.type == theType:
                print(card)

    def getCards(self):
        """
        Returns all cards held within the deck as a collection

        Parameters:
        None.

        Returns:
        Nothing.

        """

        #Returns all cards held within the deck as a collection
        return self.cards

    def saveToFile(self, fileName):
        """
        Saves the Deck to an xlsx file

        Parameters:
        fileName - the title that is supplied by the user

        Returns:
        Nothing.

        """

        wb = openpyxl.Workbook()
        ws = wb.worksheets[0]

        #Formatting the xlsx file for presentation reasons

        #Headers:
        header = ['Name','Type','Shiny','Move Name 1','Damage 1','Move Name 2','Damage 2','Move Name 3','Damage 3','Move Name 4','Damage 4','Move Name 5','Damage 5']
        ws.append(header)

        #Append the rows
        for card in self.cards:
            #Empty row
            row = []
            #Add the attributes
            row = [card.name,card.type,card.HP,card.shiny]
            #Iterate over the moves
            for move in card.moves.items():
                #Append the move name and its corresponding value
                row.append(move[0])
                row.append(move[1])

            #Append row
            ws.append(row)

        ws.cell(row=2, column=2).value = 2
        wb.save(fileName)



#*************************************************************************************************************************************



if __name__ == "__main__":

    # Testing
    x = Card('Pokemon', 'Fire', 100, {"move1": 12, "move2": 13}, True)

    print(x.getAverageDamage())

    #make new empty Deck
    myDeck = Deck()

    #print deck, should be empty
    print(myDeck.getNoOfCards())
    myDeck.inputFromFile('sampleDeck.xlsx')
    print(myDeck.getNoOfCards())

    myDeck.addCard(x)
    print(myDeck.getNoOfCards())
    myDeck.rmCard(x)
    print(myDeck.getNoOfCards())

    print(myDeck.getMostPowerful().name)
    print(myDeck.getAverageDamage())

    for card in myDeck.cards:
        print(card.averageDamage)

    myDeck.viewAllCards()
    myDeck.viewAllShinyCards()
    myDeck.viewAllByType('Water')
    myDeck.saveToFile('output.xlsx')